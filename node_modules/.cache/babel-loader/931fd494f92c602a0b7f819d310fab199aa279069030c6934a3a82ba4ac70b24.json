{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { useGesture } from '@use-gesture/react';\nconst initialModelPosition = new THREE.Vector3();\nconst mousePosition2D = new THREE.Vector2();\nconst mousePosition3D = new THREE.Vector3();\nconst dragOffset = new THREE.Vector3();\nconst dragPlaneNormal = new THREE.Vector3();\nconst dragPlane = new THREE.Plane();\nconst DragControls = /*#__PURE__*/React.forwardRef((_ref, fRef) => {\n  let {\n    autoTransform = true,\n    matrix,\n    axisLock,\n    dragLimits,\n    onHover,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    children,\n    dragConfig,\n    ...props\n  } = _ref;\n  const defaultControls = useThree(state => state.controls);\n  const {\n    camera,\n    size,\n    raycaster,\n    invalidate\n  } = useThree();\n  const ref = React.useRef(null);\n  const bind = useGesture({\n    onHover: _ref2 => {\n      let {\n        hovering\n      } = _ref2;\n      return onHover && onHover(hovering !== null && hovering !== void 0 ? hovering : false);\n    },\n    onDragStart: _ref3 => {\n      let {\n        event\n      } = _ref3;\n      if (defaultControls) defaultControls.enabled = false;\n      const {\n        point\n      } = event;\n      ref.current.matrix.decompose(initialModelPosition, new THREE.Quaternion(), new THREE.Vector3());\n      mousePosition3D.copy(point);\n      dragOffset.copy(mousePosition3D).sub(initialModelPosition);\n      onDragStart && onDragStart(initialModelPosition);\n      invalidate();\n    },\n    onDrag: _ref4 => {\n      let {\n        xy: [dragX, dragY],\n        intentional\n      } = _ref4;\n      if (!intentional) return;\n      const normalizedMouseX = (dragX - size.left) / size.width * 2 - 1;\n      const normalizedMouseY = -((dragY - size.top) / size.height) * 2 + 1;\n      mousePosition2D.set(normalizedMouseX, normalizedMouseY);\n      raycaster.setFromCamera(mousePosition2D, camera);\n      if (!axisLock) {\n        camera.getWorldDirection(dragPlaneNormal).negate();\n      } else {\n        switch (axisLock) {\n          case 'x':\n            dragPlaneNormal.set(1, 0, 0);\n            break;\n          case 'y':\n            dragPlaneNormal.set(0, 1, 0);\n            break;\n          case 'z':\n            dragPlaneNormal.set(0, 0, 1);\n            break;\n        }\n      }\n      dragPlane.setFromNormalAndCoplanarPoint(dragPlaneNormal, mousePosition3D);\n      raycaster.ray.intersectPlane(dragPlane, mousePosition3D);\n      const previousLocalMatrix = ref.current.matrix.clone();\n      const previousWorldMatrix = ref.current.matrixWorld.clone();\n      const intendedNewPosition = new THREE.Vector3(mousePosition3D.x - dragOffset.x, mousePosition3D.y - dragOffset.y, mousePosition3D.z - dragOffset.z);\n      if (dragLimits) {\n        intendedNewPosition.x = dragLimits[0] ? Math.max(Math.min(intendedNewPosition.x, dragLimits[0][1]), dragLimits[0][0]) : intendedNewPosition.x;\n        intendedNewPosition.y = dragLimits[1] ? Math.max(Math.min(intendedNewPosition.y, dragLimits[1][1]), dragLimits[1][0]) : intendedNewPosition.y;\n        intendedNewPosition.z = dragLimits[2] ? Math.max(Math.min(intendedNewPosition.z, dragLimits[2][1]), dragLimits[2][0]) : intendedNewPosition.z;\n      }\n      if (autoTransform) {\n        ref.current.matrix.setPosition(intendedNewPosition);\n        const deltaLocalMatrix = ref.current.matrix.clone().multiply(previousLocalMatrix.invert());\n        const deltaWorldMatrix = ref.current.matrix.clone().multiply(previousWorldMatrix.invert());\n        onDrag && onDrag(ref.current.matrix, deltaLocalMatrix, ref.current.matrixWorld, deltaWorldMatrix);\n      } else {\n        const tempMatrix = new THREE.Matrix4().copy(ref.current.matrix);\n        tempMatrix.setPosition(intendedNewPosition);\n        const deltaLocalMatrix = tempMatrix.clone().multiply(previousLocalMatrix.invert());\n        const deltaWorldMatrix = tempMatrix.clone().multiply(previousWorldMatrix.invert());\n        onDrag && onDrag(tempMatrix, deltaLocalMatrix, ref.current.matrixWorld, deltaWorldMatrix);\n      }\n      invalidate();\n    },\n    onDragEnd: () => {\n      if (defaultControls) defaultControls.enabled = true;\n      onDragEnd && onDragEnd();\n      invalidate();\n    }\n  }, {\n    drag: {\n      filterTaps: true,\n      threshold: 1,\n      ...(typeof dragConfig === 'object' ? dragConfig : {})\n    }\n  });\n  React.useImperativeHandle(fRef, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    if (!matrix) return;\n\n    // If the matrix is a real matrix4 it means that the user wants to control the gizmo\n    // In that case it should just be set, as a bare prop update would merely copy it\n    ref.current.matrix = matrix;\n  }, [matrix]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, bind(), {\n    matrix: matrix,\n    matrixAutoUpdate: false\n  }, props), children);\n});\nexport { DragControls };","map":{"version":3,"names":["_extends","React","THREE","useThree","useGesture","initialModelPosition","Vector3","mousePosition2D","Vector2","mousePosition3D","dragOffset","dragPlaneNormal","dragPlane","Plane","DragControls","forwardRef","_ref","fRef","autoTransform","matrix","axisLock","dragLimits","onHover","onDragStart","onDrag","onDragEnd","children","dragConfig","props","defaultControls","state","controls","camera","size","raycaster","invalidate","ref","useRef","bind","_ref2","hovering","_ref3","event","enabled","point","current","decompose","Quaternion","copy","sub","_ref4","xy","dragX","dragY","intentional","normalizedMouseX","left","width","normalizedMouseY","top","height","set","setFromCamera","getWorldDirection","negate","setFromNormalAndCoplanarPoint","ray","intersectPlane","previousLocalMatrix","clone","previousWorldMatrix","matrixWorld","intendedNewPosition","x","y","z","Math","max","min","setPosition","deltaLocalMatrix","multiply","invert","deltaWorldMatrix","tempMatrix","Matrix4","drag","filterTaps","threshold","useImperativeHandle","useLayoutEffect","createElement","matrixAutoUpdate"],"sources":["/Users/timothycharouk/Documents/my-app/node_modules/@react-three/drei/web/DragControls.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { useGesture } from '@use-gesture/react';\n\nconst initialModelPosition = new THREE.Vector3();\nconst mousePosition2D = new THREE.Vector2();\nconst mousePosition3D = new THREE.Vector3();\nconst dragOffset = new THREE.Vector3();\nconst dragPlaneNormal = new THREE.Vector3();\nconst dragPlane = new THREE.Plane();\nconst DragControls = /*#__PURE__*/React.forwardRef(({\n  autoTransform = true,\n  matrix,\n  axisLock,\n  dragLimits,\n  onHover,\n  onDragStart,\n  onDrag,\n  onDragEnd,\n  children,\n  dragConfig,\n  ...props\n}, fRef) => {\n  const defaultControls = useThree(state => state.controls);\n  const {\n    camera,\n    size,\n    raycaster,\n    invalidate\n  } = useThree();\n  const ref = React.useRef(null);\n  const bind = useGesture({\n    onHover: ({\n      hovering\n    }) => onHover && onHover(hovering !== null && hovering !== void 0 ? hovering : false),\n    onDragStart: ({\n      event\n    }) => {\n      if (defaultControls) defaultControls.enabled = false;\n      const {\n        point\n      } = event;\n      ref.current.matrix.decompose(initialModelPosition, new THREE.Quaternion(), new THREE.Vector3());\n      mousePosition3D.copy(point);\n      dragOffset.copy(mousePosition3D).sub(initialModelPosition);\n      onDragStart && onDragStart(initialModelPosition);\n      invalidate();\n    },\n    onDrag: ({\n      xy: [dragX, dragY],\n      intentional\n    }) => {\n      if (!intentional) return;\n      const normalizedMouseX = (dragX - size.left) / size.width * 2 - 1;\n      const normalizedMouseY = -((dragY - size.top) / size.height) * 2 + 1;\n      mousePosition2D.set(normalizedMouseX, normalizedMouseY);\n      raycaster.setFromCamera(mousePosition2D, camera);\n      if (!axisLock) {\n        camera.getWorldDirection(dragPlaneNormal).negate();\n      } else {\n        switch (axisLock) {\n          case 'x':\n            dragPlaneNormal.set(1, 0, 0);\n            break;\n          case 'y':\n            dragPlaneNormal.set(0, 1, 0);\n            break;\n          case 'z':\n            dragPlaneNormal.set(0, 0, 1);\n            break;\n        }\n      }\n      dragPlane.setFromNormalAndCoplanarPoint(dragPlaneNormal, mousePosition3D);\n      raycaster.ray.intersectPlane(dragPlane, mousePosition3D);\n      const previousLocalMatrix = ref.current.matrix.clone();\n      const previousWorldMatrix = ref.current.matrixWorld.clone();\n      const intendedNewPosition = new THREE.Vector3(mousePosition3D.x - dragOffset.x, mousePosition3D.y - dragOffset.y, mousePosition3D.z - dragOffset.z);\n      if (dragLimits) {\n        intendedNewPosition.x = dragLimits[0] ? Math.max(Math.min(intendedNewPosition.x, dragLimits[0][1]), dragLimits[0][0]) : intendedNewPosition.x;\n        intendedNewPosition.y = dragLimits[1] ? Math.max(Math.min(intendedNewPosition.y, dragLimits[1][1]), dragLimits[1][0]) : intendedNewPosition.y;\n        intendedNewPosition.z = dragLimits[2] ? Math.max(Math.min(intendedNewPosition.z, dragLimits[2][1]), dragLimits[2][0]) : intendedNewPosition.z;\n      }\n      if (autoTransform) {\n        ref.current.matrix.setPosition(intendedNewPosition);\n        const deltaLocalMatrix = ref.current.matrix.clone().multiply(previousLocalMatrix.invert());\n        const deltaWorldMatrix = ref.current.matrix.clone().multiply(previousWorldMatrix.invert());\n        onDrag && onDrag(ref.current.matrix, deltaLocalMatrix, ref.current.matrixWorld, deltaWorldMatrix);\n      } else {\n        const tempMatrix = new THREE.Matrix4().copy(ref.current.matrix);\n        tempMatrix.setPosition(intendedNewPosition);\n        const deltaLocalMatrix = tempMatrix.clone().multiply(previousLocalMatrix.invert());\n        const deltaWorldMatrix = tempMatrix.clone().multiply(previousWorldMatrix.invert());\n        onDrag && onDrag(tempMatrix, deltaLocalMatrix, ref.current.matrixWorld, deltaWorldMatrix);\n      }\n      invalidate();\n    },\n    onDragEnd: () => {\n      if (defaultControls) defaultControls.enabled = true;\n      onDragEnd && onDragEnd();\n      invalidate();\n    }\n  }, {\n    drag: {\n      filterTaps: true,\n      threshold: 1,\n      ...(typeof dragConfig === 'object' ? dragConfig : {})\n    }\n  });\n  React.useImperativeHandle(fRef, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    if (!matrix) return;\n\n    // If the matrix is a real matrix4 it means that the user wants to control the gizmo\n    // In that case it should just be set, as a bare prop update would merely copy it\n    ref.current.matrix = matrix;\n  }, [matrix]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, bind(), {\n    matrix: matrix,\n    matrixAutoUpdate: false\n  }, props), children);\n});\n\nexport { DragControls };\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,oCAAoC;AACzD,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,QAAQ,QAAQ,oBAAoB;AAC7C,SAASC,UAAU,QAAQ,oBAAoB;AAE/C,MAAMC,oBAAoB,GAAG,IAAIH,KAAK,CAACI,OAAO,CAAC,CAAC;AAChD,MAAMC,eAAe,GAAG,IAAIL,KAAK,CAACM,OAAO,CAAC,CAAC;AAC3C,MAAMC,eAAe,GAAG,IAAIP,KAAK,CAACI,OAAO,CAAC,CAAC;AAC3C,MAAMI,UAAU,GAAG,IAAIR,KAAK,CAACI,OAAO,CAAC,CAAC;AACtC,MAAMK,eAAe,GAAG,IAAIT,KAAK,CAACI,OAAO,CAAC,CAAC;AAC3C,MAAMM,SAAS,GAAG,IAAIV,KAAK,CAACW,KAAK,CAAC,CAAC;AACnC,MAAMC,YAAY,GAAG,aAAab,KAAK,CAACc,UAAU,CAAC,CAAAC,IAAA,EAYhDC,IAAI,KAAK;EAAA,IAZwC;IAClDC,aAAa,GAAG,IAAI;IACpBC,MAAM;IACNC,QAAQ;IACRC,UAAU;IACVC,OAAO;IACPC,WAAW;IACXC,MAAM;IACNC,SAAS;IACTC,QAAQ;IACRC,UAAU;IACV,GAAGC;EACL,CAAC,GAAAZ,IAAA;EACC,MAAMa,eAAe,GAAG1B,QAAQ,CAAC2B,KAAK,IAAIA,KAAK,CAACC,QAAQ,CAAC;EACzD,MAAM;IACJC,MAAM;IACNC,IAAI;IACJC,SAAS;IACTC;EACF,CAAC,GAAGhC,QAAQ,CAAC,CAAC;EACd,MAAMiC,GAAG,GAAGnC,KAAK,CAACoC,MAAM,CAAC,IAAI,CAAC;EAC9B,MAAMC,IAAI,GAAGlC,UAAU,CAAC;IACtBkB,OAAO,EAAEiB,KAAA;MAAA,IAAC;QACRC;MACF,CAAC,GAAAD,KAAA;MAAA,OAAKjB,OAAO,IAAIA,OAAO,CAACkB,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAGA,QAAQ,GAAG,KAAK,CAAC;IAAA;IACrFjB,WAAW,EAAEkB,KAAA,IAEP;MAAA,IAFQ;QACZC;MACF,CAAC,GAAAD,KAAA;MACC,IAAIZ,eAAe,EAAEA,eAAe,CAACc,OAAO,GAAG,KAAK;MACpD,MAAM;QACJC;MACF,CAAC,GAAGF,KAAK;MACTN,GAAG,CAACS,OAAO,CAAC1B,MAAM,CAAC2B,SAAS,CAACzC,oBAAoB,EAAE,IAAIH,KAAK,CAAC6C,UAAU,CAAC,CAAC,EAAE,IAAI7C,KAAK,CAACI,OAAO,CAAC,CAAC,CAAC;MAC/FG,eAAe,CAACuC,IAAI,CAACJ,KAAK,CAAC;MAC3BlC,UAAU,CAACsC,IAAI,CAACvC,eAAe,CAAC,CAACwC,GAAG,CAAC5C,oBAAoB,CAAC;MAC1DkB,WAAW,IAAIA,WAAW,CAAClB,oBAAoB,CAAC;MAChD8B,UAAU,CAAC,CAAC;IACd,CAAC;IACDX,MAAM,EAAE0B,KAAA,IAGF;MAAA,IAHG;QACPC,EAAE,EAAE,CAACC,KAAK,EAAEC,KAAK,CAAC;QAClBC;MACF,CAAC,GAAAJ,KAAA;MACC,IAAI,CAACI,WAAW,EAAE;MAClB,MAAMC,gBAAgB,GAAG,CAACH,KAAK,GAAGnB,IAAI,CAACuB,IAAI,IAAIvB,IAAI,CAACwB,KAAK,GAAG,CAAC,GAAG,CAAC;MACjE,MAAMC,gBAAgB,GAAG,EAAE,CAACL,KAAK,GAAGpB,IAAI,CAAC0B,GAAG,IAAI1B,IAAI,CAAC2B,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC;MACpErD,eAAe,CAACsD,GAAG,CAACN,gBAAgB,EAAEG,gBAAgB,CAAC;MACvDxB,SAAS,CAAC4B,aAAa,CAACvD,eAAe,EAAEyB,MAAM,CAAC;MAChD,IAAI,CAACZ,QAAQ,EAAE;QACbY,MAAM,CAAC+B,iBAAiB,CAACpD,eAAe,CAAC,CAACqD,MAAM,CAAC,CAAC;MACpD,CAAC,MAAM;QACL,QAAQ5C,QAAQ;UACd,KAAK,GAAG;YACNT,eAAe,CAACkD,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;YAC5B;UACF,KAAK,GAAG;YACNlD,eAAe,CAACkD,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;YAC5B;UACF,KAAK,GAAG;YACNlD,eAAe,CAACkD,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;YAC5B;QACJ;MACF;MACAjD,SAAS,CAACqD,6BAA6B,CAACtD,eAAe,EAAEF,eAAe,CAAC;MACzEyB,SAAS,CAACgC,GAAG,CAACC,cAAc,CAACvD,SAAS,EAAEH,eAAe,CAAC;MACxD,MAAM2D,mBAAmB,GAAGhC,GAAG,CAACS,OAAO,CAAC1B,MAAM,CAACkD,KAAK,CAAC,CAAC;MACtD,MAAMC,mBAAmB,GAAGlC,GAAG,CAACS,OAAO,CAAC0B,WAAW,CAACF,KAAK,CAAC,CAAC;MAC3D,MAAMG,mBAAmB,GAAG,IAAItE,KAAK,CAACI,OAAO,CAACG,eAAe,CAACgE,CAAC,GAAG/D,UAAU,CAAC+D,CAAC,EAAEhE,eAAe,CAACiE,CAAC,GAAGhE,UAAU,CAACgE,CAAC,EAAEjE,eAAe,CAACkE,CAAC,GAAGjE,UAAU,CAACiE,CAAC,CAAC;MACnJ,IAAItD,UAAU,EAAE;QACdmD,mBAAmB,CAACC,CAAC,GAAGpD,UAAU,CAAC,CAAC,CAAC,GAAGuD,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,GAAG,CAACN,mBAAmB,CAACC,CAAC,EAAEpD,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGmD,mBAAmB,CAACC,CAAC;QAC7ID,mBAAmB,CAACE,CAAC,GAAGrD,UAAU,CAAC,CAAC,CAAC,GAAGuD,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,GAAG,CAACN,mBAAmB,CAACE,CAAC,EAAErD,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGmD,mBAAmB,CAACE,CAAC;QAC7IF,mBAAmB,CAACG,CAAC,GAAGtD,UAAU,CAAC,CAAC,CAAC,GAAGuD,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,GAAG,CAACN,mBAAmB,CAACG,CAAC,EAAEtD,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGmD,mBAAmB,CAACG,CAAC;MAC/I;MACA,IAAIzD,aAAa,EAAE;QACjBkB,GAAG,CAACS,OAAO,CAAC1B,MAAM,CAAC4D,WAAW,CAACP,mBAAmB,CAAC;QACnD,MAAMQ,gBAAgB,GAAG5C,GAAG,CAACS,OAAO,CAAC1B,MAAM,CAACkD,KAAK,CAAC,CAAC,CAACY,QAAQ,CAACb,mBAAmB,CAACc,MAAM,CAAC,CAAC,CAAC;QAC1F,MAAMC,gBAAgB,GAAG/C,GAAG,CAACS,OAAO,CAAC1B,MAAM,CAACkD,KAAK,CAAC,CAAC,CAACY,QAAQ,CAACX,mBAAmB,CAACY,MAAM,CAAC,CAAC,CAAC;QAC1F1D,MAAM,IAAIA,MAAM,CAACY,GAAG,CAACS,OAAO,CAAC1B,MAAM,EAAE6D,gBAAgB,EAAE5C,GAAG,CAACS,OAAO,CAAC0B,WAAW,EAAEY,gBAAgB,CAAC;MACnG,CAAC,MAAM;QACL,MAAMC,UAAU,GAAG,IAAIlF,KAAK,CAACmF,OAAO,CAAC,CAAC,CAACrC,IAAI,CAACZ,GAAG,CAACS,OAAO,CAAC1B,MAAM,CAAC;QAC/DiE,UAAU,CAACL,WAAW,CAACP,mBAAmB,CAAC;QAC3C,MAAMQ,gBAAgB,GAAGI,UAAU,CAACf,KAAK,CAAC,CAAC,CAACY,QAAQ,CAACb,mBAAmB,CAACc,MAAM,CAAC,CAAC,CAAC;QAClF,MAAMC,gBAAgB,GAAGC,UAAU,CAACf,KAAK,CAAC,CAAC,CAACY,QAAQ,CAACX,mBAAmB,CAACY,MAAM,CAAC,CAAC,CAAC;QAClF1D,MAAM,IAAIA,MAAM,CAAC4D,UAAU,EAAEJ,gBAAgB,EAAE5C,GAAG,CAACS,OAAO,CAAC0B,WAAW,EAAEY,gBAAgB,CAAC;MAC3F;MACAhD,UAAU,CAAC,CAAC;IACd,CAAC;IACDV,SAAS,EAAEA,CAAA,KAAM;MACf,IAAII,eAAe,EAAEA,eAAe,CAACc,OAAO,GAAG,IAAI;MACnDlB,SAAS,IAAIA,SAAS,CAAC,CAAC;MACxBU,UAAU,CAAC,CAAC;IACd;EACF,CAAC,EAAE;IACDmD,IAAI,EAAE;MACJC,UAAU,EAAE,IAAI;MAChBC,SAAS,EAAE,CAAC;MACZ,IAAI,OAAO7D,UAAU,KAAK,QAAQ,GAAGA,UAAU,GAAG,CAAC,CAAC;IACtD;EACF,CAAC,CAAC;EACF1B,KAAK,CAACwF,mBAAmB,CAACxE,IAAI,EAAE,MAAMmB,GAAG,CAACS,OAAO,EAAE,EAAE,CAAC;EACtD5C,KAAK,CAACyF,eAAe,CAAC,MAAM;IAC1B,IAAI,CAACvE,MAAM,EAAE;;IAEb;IACA;IACAiB,GAAG,CAACS,OAAO,CAAC1B,MAAM,GAAGA,MAAM;EAC7B,CAAC,EAAE,CAACA,MAAM,CAAC,CAAC;EACZ,OAAO,aAAalB,KAAK,CAAC0F,aAAa,CAAC,OAAO,EAAE3F,QAAQ,CAAC;IACxDoC,GAAG,EAAEA;EACP,CAAC,EAAEE,IAAI,CAAC,CAAC,EAAE;IACTnB,MAAM,EAAEA,MAAM;IACdyE,gBAAgB,EAAE;EACpB,CAAC,EAAEhE,KAAK,CAAC,EAAEF,QAAQ,CAAC;AACtB,CAAC,CAAC;AAEF,SAASZ,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}