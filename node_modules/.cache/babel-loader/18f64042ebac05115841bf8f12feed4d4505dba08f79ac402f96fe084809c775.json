{"ast":null,"code":"/**\n * @monogrid/gainmap-js v3.0.5\n * With ❤️, by MONOGRID <rnd@monogrid.com>\n */\n\nimport { Q as QuadRenderer } from './QuadRenderer-6HrRQdJM.js';\nimport { ShaderMaterial, Vector3, NoBlending, SRGBColorSpace, LinearSRGBColorSpace, HalfFloatType, Loader, LoadingManager, Texture, UVMapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, FileLoader } from 'three';\nconst vertexShader = /* glsl */\"\\nvarying vec2 vUv;\\n\\nvoid main() {\\n  vUv = uv;\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n\";\nconst fragmentShader = /* glsl */\"\\n// min half float value\\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\\n// max half float value\\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\\n\\nuniform sampler2D sdr;\\nuniform sampler2D gainMap;\\nuniform vec3 gamma;\\nuniform vec3 offsetHdr;\\nuniform vec3 offsetSdr;\\nuniform vec3 gainMapMin;\\nuniform vec3 gainMapMax;\\nuniform float weightFactor;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\\n  vec3 logRecovery = pow( recovery, gamma );\\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\\n}\\n\";\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapDecoderMaterial extends ShaderMaterial {\n  /**\n   *\n   * @param params\n   */\n  constructor(_ref) {\n    let {\n      gamma,\n      offsetHdr,\n      offsetSdr,\n      gainMapMin,\n      gainMapMax,\n      maxDisplayBoost,\n      hdrCapacityMin,\n      hdrCapacityMax,\n      sdr,\n      gainMap\n    } = _ref;\n    super({\n      name: 'GainMapDecoderMaterial',\n      vertexShader,\n      fragmentShader,\n      uniforms: {\n        sdr: {\n          value: sdr\n        },\n        gainMap: {\n          value: gainMap\n        },\n        gamma: {\n          value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2])\n        },\n        offsetHdr: {\n          value: new Vector3().fromArray(offsetHdr)\n        },\n        offsetSdr: {\n          value: new Vector3().fromArray(offsetSdr)\n        },\n        gainMapMin: {\n          value: new Vector3().fromArray(gainMapMin)\n        },\n        gainMapMax: {\n          value: new Vector3().fromArray(gainMapMax)\n        },\n        weightFactor: {\n          value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n        }\n      },\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false\n    });\n    this._maxDisplayBoost = maxDisplayBoost;\n    this._hdrCapacityMin = hdrCapacityMin;\n    this._hdrCapacityMax = hdrCapacityMax;\n    this.needsUpdate = true;\n    this.uniformsNeedUpdate = true;\n  }\n  get sdr() {\n    return this.uniforms.sdr.value;\n  }\n  set sdr(value) {\n    this.uniforms.sdr.value = value;\n  }\n  get gainMap() {\n    return this.uniforms.gainMap.value;\n  }\n  set gainMap(value) {\n    this.uniforms.gainMap.value = value;\n  }\n  /**\n   * @see {@link GainMapMetadata.offsetHdr}\n   */\n  get offsetHdr() {\n    return this.uniforms.offsetHdr.value.toArray();\n  }\n  set offsetHdr(value) {\n    this.uniforms.offsetHdr.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.offsetSdr}\n   */\n  get offsetSdr() {\n    return this.uniforms.offsetSdr.value.toArray();\n  }\n  set offsetSdr(value) {\n    this.uniforms.offsetSdr.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.gainMapMin}\n   */\n  get gainMapMin() {\n    return this.uniforms.gainMapMin.value.toArray();\n  }\n  set gainMapMin(value) {\n    this.uniforms.gainMapMin.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.gainMapMax}\n   */\n  get gainMapMax() {\n    return this.uniforms.gainMapMax.value.toArray();\n  }\n  set gainMapMax(value) {\n    this.uniforms.gainMapMax.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.gamma}\n   */\n  get gamma() {\n    const g = this.uniforms.gamma.value;\n    return [1 / g.x, 1 / g.y, 1 / g.z];\n  }\n  set gamma(value) {\n    const g = this.uniforms.gamma.value;\n    g.x = 1.0 / value[0];\n    g.y = 1.0 / value[1];\n    g.z = 1.0 / value[2];\n  }\n  /**\n   * @see {@link GainMapMetadata.hdrCapacityMin}\n   * @remarks Logarithmic space\n   */\n  get hdrCapacityMin() {\n    return this._hdrCapacityMin;\n  }\n  set hdrCapacityMin(value) {\n    this._hdrCapacityMin = value;\n    this.calculateWeight();\n  }\n  /**\n   * @see {@link GainMapMetadata.hdrCapacityMin}\n   * @remarks Logarithmic space\n   */\n  get hdrCapacityMax() {\n    return this._hdrCapacityMax;\n  }\n  set hdrCapacityMax(value) {\n    this._hdrCapacityMax = value;\n    this.calculateWeight();\n  }\n  /**\n   * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n   * @remarks Non Logarithmic space\n   */\n  get maxDisplayBoost() {\n    return this._maxDisplayBoost;\n  }\n  set maxDisplayBoost(value) {\n    this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n    this.calculateWeight();\n  }\n  calculateWeight() {\n    const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n    this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n  }\n}\n\n/**\n * Decodes a gain map using a WebGLRenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = await decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nconst decode = params => {\n  const {\n    sdr,\n    gainMap,\n    renderer\n  } = params;\n  if (sdr.colorSpace !== SRGBColorSpace) {\n    console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n    sdr.colorSpace = SRGBColorSpace;\n  }\n  sdr.needsUpdate = true;\n  if (gainMap.colorSpace !== LinearSRGBColorSpace) {\n    console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n    gainMap.colorSpace = LinearSRGBColorSpace;\n  }\n  gainMap.needsUpdate = true;\n  const material = new GainMapDecoderMaterial({\n    ...params,\n    sdr,\n    gainMap\n  });\n  const quadRenderer = new QuadRenderer({\n    // TODO: three types are generic, eslint complains here, see how we can solve\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n    width: sdr.image.width,\n    // TODO: three types are generic, eslint complains here, see how we can solve\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n    height: sdr.image.height,\n    type: HalfFloatType,\n    colorSpace: LinearSRGBColorSpace,\n    material,\n    renderer,\n    renderTargetOptions: params.renderTargetOptions\n  });\n  try {\n    quadRenderer.render();\n  } catch (e) {\n    quadRenderer.disposeOnDemandRenderer();\n    throw e;\n  }\n  return quadRenderer;\n};\nclass GainMapNotFoundError extends Error {}\nclass XMPMetadataNotFoundError extends Error {}\nconst getAttribute = (description, name, defaultValue) => {\n  var _a;\n  let returnValue;\n  const parsedValue = (_a = description.attributes.getNamedItem(name)) === null || _a === void 0 ? void 0 : _a.nodeValue;\n  if (!parsedValue) {\n    const node = description.getElementsByTagName(name)[0];\n    if (node) {\n      const values = node.getElementsByTagName('rdf:li');\n      if (values.length === 3) {\n        returnValue = Array.from(values).map(v => v.innerHTML);\n      } else {\n        throw new Error(\"Gainmap metadata contains an array of items for \".concat(name, \" but its length is not 3\"));\n      }\n    } else {\n      if (defaultValue) return defaultValue;else throw new Error(\"Can't find \".concat(name, \" in gainmap metadata\"));\n    }\n  } else {\n    returnValue = parsedValue;\n  }\n  return returnValue;\n};\n/**\n *\n * @param input\n * @returns\n */\nconst extractXMP = input => {\n  var _a, _b;\n  let str;\n  // support node test environment\n  if (typeof TextDecoder !== 'undefined') str = new TextDecoder().decode(input);else str = input.toString();\n  let start = str.indexOf('<x:xmpmeta');\n  const parser = new DOMParser();\n  while (start !== -1) {\n    const end = str.indexOf('x:xmpmeta>', start);\n    str.slice(start, end + 10);\n    const xmpBlock = str.slice(start, end + 10);\n    try {\n      const xmlDocument = parser.parseFromString(xmpBlock, 'text/xml');\n      const description = xmlDocument.getElementsByTagName('rdf:Description')[0];\n      const gainMapMin = getAttribute(description, 'hdrgm:GainMapMin', '0');\n      const gainMapMax = getAttribute(description, 'hdrgm:GainMapMax');\n      const gamma = getAttribute(description, 'hdrgm:Gamma', '1');\n      const offsetSDR = getAttribute(description, 'hdrgm:OffsetSDR', '0.015625');\n      const offsetHDR = getAttribute(description, 'hdrgm:OffsetHDR', '0.015625');\n      let hdrCapacityMin = (_a = description.attributes.getNamedItem('hdrgm:HDRCapacityMin')) === null || _a === void 0 ? void 0 : _a.nodeValue;\n      if (!hdrCapacityMin) hdrCapacityMin = '0';\n      const hdrCapacityMax = (_b = description.attributes.getNamedItem('hdrgm:HDRCapacityMax')) === null || _b === void 0 ? void 0 : _b.nodeValue;\n      if (!hdrCapacityMax) throw new Error('Incomplete gainmap metadata');\n      return {\n        gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n        gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n        gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n        offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n        offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n        hdrCapacityMin: parseFloat(hdrCapacityMin),\n        hdrCapacityMax: parseFloat(hdrCapacityMax)\n      };\n    } catch (e) {}\n    start = str.indexOf('<x:xmpmeta', end);\n  }\n};\n\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */\nclass MPFExtractor {\n  constructor(options) {\n    this.options = {\n      debug: options && options.debug !== undefined ? options.debug : false,\n      extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n      extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n    };\n  }\n  extract(imageArrayBuffer) {\n    return new Promise((resolve, reject) => {\n      const debug = this.options.debug;\n      const dataView = new DataView(imageArrayBuffer.buffer);\n      // If you're executing this line on a big endian machine, it'll be reversed.\n      // bigEnd further down though, refers to the endianness of the image itself.\n      if (dataView.getUint16(0) !== 0xffd8) {\n        reject(new Error('Not a valid jpeg'));\n        return;\n      }\n      const length = dataView.byteLength;\n      let offset = 2;\n      let loops = 0;\n      let marker; // APP# marker\n      while (offset < length) {\n        if (++loops > 250) {\n          reject(new Error(\"Found no marker after \".concat(loops, \" loops \\uD83D\\uDE35\")));\n          return;\n        }\n        if (dataView.getUint8(offset) !== 0xff) {\n          reject(new Error(\"Not a valid marker at offset 0x\".concat(offset.toString(16), \", found: 0x\").concat(dataView.getUint8(offset).toString(16))));\n          return;\n        }\n        marker = dataView.getUint8(offset + 1);\n        if (debug) console.log(\"Marker: \".concat(marker.toString(16)));\n        if (marker === 0xe2) {\n          if (debug) console.log('Found APP2 marker (0xffe2)');\n          // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n          // Great way to visualize image information in html is using Exiftool. E.g.:\n          // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n          const formatPt = offset + 4;\n          /*\n           *  Structure of the MP Format Identifier\n           *\n           *  Offset Addr.  | Code (Hex)  | Description\n           *  +00             ff            Marker Prefix      <-- offset\n           *  +01             e2            APP2\n           *  +02             #n            APP2 Field Length\n           *  +03             #n            APP2 Field Length\n           *  +04             4d            'M'                <-- formatPt\n           *  +05             50            'P'\n           *  +06             46            'F'\n           *  +07             00            NULL\n           *                                                   <-- tiffOffset\n           */\n          if (dataView.getUint32(formatPt) === 0x4d504600) {\n            // Found MPF tag, so we start dig out sub images\n            const tiffOffset = formatPt + 4;\n            let bigEnd; // Endianness from TIFF header\n            // Test for TIFF validity and endianness\n            // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n            if (dataView.getUint16(tiffOffset) === 0x4949) {\n              bigEnd = false;\n            } else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n              bigEnd = true;\n            } else {\n              reject(new Error('No valid endianness marker found in TIFF header'));\n              return;\n            }\n            if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n              reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n              return;\n            }\n            // 32 bit number stating the offset from the start of the 8 Byte MP Header\n            // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n            const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n            if (firstIFDOffset < 0x00000008) {\n              reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n              return;\n            }\n            // Move ahead to MP Index IFD\n            // Assume we're at the first IFD, so firstIFDOffset points to\n            // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n            // we fail silently here due to this assumption)\n            // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n            const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n            const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n            // Extract info from MPEntries (starting after Count)\n            const entriesStart = dirStart + 2;\n            let numberOfImages = 0;\n            for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n              // Each entry is 12 Bytes long\n              // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n              if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                // stored in Last 4 bytes of its 12 Byte entry.\n                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n              }\n            }\n            const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n            const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n            const images = [];\n            for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n              const image = {\n                MPType: dataView.getUint32(i, !bigEnd),\n                size: dataView.getUint32(i + 4, !bigEnd),\n                // This offset is specified relative to the address of the MP Endian\n                // field in the MP Header, unless the image is a First Individual Image,\n                // in which case the value of the offset shall be NULL (0x00000000).\n                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                start: -1,\n                end: -1,\n                isFII: false\n              };\n              if (!image.dataOffset) {\n                // dataOffset is 0x00000000 for First Individual Image\n                image.start = 0;\n                image.isFII = true;\n              } else {\n                image.start = tiffOffset + image.dataOffset;\n                image.isFII = false;\n              }\n              image.end = image.start + image.size;\n              images.push(image);\n            }\n            if (this.options.extractNonFII && images.length) {\n              const bufferBlob = new Blob([dataView]);\n              const imgs = [];\n              for (const image of images) {\n                if (image.isFII && !this.options.extractFII) {\n                  continue; // Skip FII\n                }\n                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                // we don't need this\n                // const imageUrl = URL.createObjectURL(imageBlob)\n                // image.img = document.createElement('img')\n                // image.img.src = imageUrl\n                imgs.push(imageBlob);\n              }\n              resolve(imgs);\n            }\n          }\n        }\n        offset += 2 + dataView.getUint16(offset + 2);\n      }\n    });\n  }\n}\n\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */\nconst extractGainmapFromJPEG = async jpegFile => {\n  const metadata = extractXMP(jpegFile);\n  if (!metadata) throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n  const mpfExtractor = new MPFExtractor({\n    extractFII: true,\n    extractNonFII: true\n  });\n  const images = await mpfExtractor.extract(jpegFile);\n  if (images.length !== 2) throw new GainMapNotFoundError('Gain map recovery image not found');\n  return {\n    sdr: new Uint8Array(await images[0].arrayBuffer()),\n    gainMap: new Uint8Array(await images[1].arrayBuffer()),\n    metadata\n  };\n};\n\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */\nconst getHTMLImageFromBlob = blob => {\n  return new Promise((resolve, reject) => {\n    const img = document.createElement('img');\n    img.onload = () => {\n      resolve(img);\n    };\n    img.onerror = e => {\n      reject(e);\n    };\n    img.src = URL.createObjectURL(blob);\n  });\n};\nclass LoaderBase extends Loader {\n  /**\n   *\n   * @param renderer\n   * @param manager\n   */\n  constructor(renderer, manager) {\n    super(manager);\n    if (renderer) this._renderer = renderer;\n    this._internalLoadingManager = new LoadingManager();\n  }\n  /**\n   * Specify the renderer to use when rendering the gain map\n   *\n   * @param renderer\n   * @returns\n   */\n  setRenderer(renderer) {\n    this._renderer = renderer;\n    return this;\n  }\n  /**\n   * Specify the renderTarget options to use when rendering the gain map\n   *\n   * @param options\n   * @returns\n   */\n  setRenderTargetOptions(options) {\n    this._renderTargetOptions = options;\n    return this;\n  }\n  /**\n   * @private\n   * @returns\n   */\n  prepareQuadRenderer() {\n    if (!this._renderer) console.warn('WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n    // temporary values\n    const material = new GainMapDecoderMaterial({\n      gainMapMax: [1, 1, 1],\n      gainMapMin: [0, 0, 0],\n      gamma: [1, 1, 1],\n      offsetHdr: [1, 1, 1],\n      offsetSdr: [1, 1, 1],\n      hdrCapacityMax: 1,\n      hdrCapacityMin: 0,\n      maxDisplayBoost: 1,\n      gainMap: new Texture(),\n      sdr: new Texture()\n    });\n    return new QuadRenderer({\n      width: 16,\n      height: 16,\n      type: HalfFloatType,\n      colorSpace: LinearSRGBColorSpace,\n      material,\n      renderer: this._renderer,\n      renderTargetOptions: this._renderTargetOptions\n    });\n  }\n  /**\n  * @private\n  * @param quadRenderer\n  * @param metadata\n  * @param sdrBuffer\n  * @param gainMapBuffer\n  */\n  async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n    // this is optional, will render a black gain-map if not present\n    const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], {\n      type: 'image/jpeg'\n    }) : undefined;\n    const sdrBlob = new Blob([sdrBuffer], {\n      type: 'image/jpeg'\n    });\n    let sdrImage;\n    let gainMapImage;\n    let needsFlip = false;\n    if (typeof createImageBitmap === 'undefined') {\n      const res = await Promise.all([gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined), getHTMLImageFromBlob(sdrBlob)]);\n      gainMapImage = res[0];\n      sdrImage = res[1];\n      needsFlip = true;\n    } else {\n      const res = await Promise.all([gainMapBlob ? createImageBitmap(gainMapBlob, {\n        imageOrientation: 'flipY'\n      }) : Promise.resolve(undefined), createImageBitmap(sdrBlob, {\n        imageOrientation: 'flipY'\n      })]);\n      gainMapImage = res[0];\n      sdrImage = res[1];\n    }\n    const gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);\n    gainMap.flipY = needsFlip;\n    gainMap.needsUpdate = true;\n    const sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);\n    sdr.flipY = needsFlip;\n    sdr.needsUpdate = true;\n    quadRenderer.width = sdrImage.width;\n    quadRenderer.height = sdrImage.height;\n    quadRenderer.material.gainMap = gainMap;\n    quadRenderer.material.sdr = sdr;\n    quadRenderer.material.gainMapMin = metadata.gainMapMin;\n    quadRenderer.material.gainMapMax = metadata.gainMapMax;\n    quadRenderer.material.offsetHdr = metadata.offsetHdr;\n    quadRenderer.material.offsetSdr = metadata.offsetSdr;\n    quadRenderer.material.gamma = metadata.gamma;\n    quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n    quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n    quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n    quadRenderer.material.needsUpdate = true;\n    quadRenderer.render();\n  }\n}\n\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass GainMapLoader extends LoaderBase {\n  /**\n   * Loads a gainmap using separate data\n   * * sdr image\n   * * gain map image\n   * * metadata json\n   *\n   * useful for webp gain maps\n   *\n   * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n   * @param onLoad Load complete callback, will receive the result\n   * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n   * @param onError Error callback\n   * @returns\n   */\n  load(_ref2, onLoad, onProgress, onError) {\n    let [sdrUrl, gainMapUrl, metadataUrl] = _ref2;\n    const quadRenderer = this.prepareQuadRenderer();\n    let sdr;\n    let gainMap;\n    let metadata;\n    const loadCheck = async () => {\n      if (sdr && gainMap && metadata) {\n        // solves #16\n        try {\n          await this.render(quadRenderer, metadata, sdr, gainMap);\n        } catch (error) {\n          this.manager.itemError(sdrUrl);\n          this.manager.itemError(gainMapUrl);\n          this.manager.itemError(metadataUrl);\n          if (typeof onError === 'function') onError(error);\n          quadRenderer.disposeOnDemandRenderer();\n          return;\n        }\n        if (typeof onLoad === 'function') onLoad(quadRenderer);\n        this.manager.itemEnd(sdrUrl);\n        this.manager.itemEnd(gainMapUrl);\n        this.manager.itemEnd(metadataUrl);\n        quadRenderer.disposeOnDemandRenderer();\n      }\n    };\n    let sdrLengthComputable = true;\n    let sdrTotal = 0;\n    let sdrLoaded = 0;\n    let gainMapLengthComputable = true;\n    let gainMapTotal = 0;\n    let gainMapLoaded = 0;\n    let metadataLengthComputable = true;\n    let metadataTotal = 0;\n    let metadataLoaded = 0;\n    const progressHandler = () => {\n      if (typeof onProgress === 'function') {\n        const total = sdrTotal + gainMapTotal + metadataTotal;\n        const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n        const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n        onProgress(new ProgressEvent('progress', {\n          lengthComputable,\n          loaded,\n          total\n        }));\n      }\n    };\n    this.manager.itemStart(sdrUrl);\n    this.manager.itemStart(gainMapUrl);\n    this.manager.itemStart(metadataUrl);\n    const sdrLoader = new FileLoader(this._internalLoadingManager);\n    sdrLoader.setResponseType('arraybuffer');\n    sdrLoader.setRequestHeader(this.requestHeader);\n    sdrLoader.setPath(this.path);\n    sdrLoader.setWithCredentials(this.withCredentials);\n    sdrLoader.load(sdrUrl, async buffer => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof buffer === 'string') throw new Error('Invalid sdr buffer');\n      sdr = buffer;\n      await loadCheck();\n    }, e => {\n      sdrLengthComputable = e.lengthComputable;\n      sdrLoaded = e.loaded;\n      sdrTotal = e.total;\n      progressHandler();\n    }, error => {\n      this.manager.itemError(sdrUrl);\n      if (typeof onError === 'function') onError(error);\n    });\n    const gainMapLoader = new FileLoader(this._internalLoadingManager);\n    gainMapLoader.setResponseType('arraybuffer');\n    gainMapLoader.setRequestHeader(this.requestHeader);\n    gainMapLoader.setPath(this.path);\n    gainMapLoader.setWithCredentials(this.withCredentials);\n    gainMapLoader.load(gainMapUrl, async buffer => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof buffer === 'string') throw new Error('Invalid gainmap buffer');\n      gainMap = buffer;\n      await loadCheck();\n    }, e => {\n      gainMapLengthComputable = e.lengthComputable;\n      gainMapLoaded = e.loaded;\n      gainMapTotal = e.total;\n      progressHandler();\n    }, error => {\n      this.manager.itemError(gainMapUrl);\n      if (typeof onError === 'function') onError(error);\n    });\n    const metadataLoader = new FileLoader(this._internalLoadingManager);\n    // metadataLoader.setResponseType('json')\n    metadataLoader.setRequestHeader(this.requestHeader);\n    metadataLoader.setPath(this.path);\n    metadataLoader.setWithCredentials(this.withCredentials);\n    metadataLoader.load(metadataUrl, async json => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof json !== 'string') throw new Error('Invalid metadata string');\n      // TODO: implement check on JSON file and remove this eslint disable\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      metadata = JSON.parse(json);\n      await loadCheck();\n    }, e => {\n      metadataLengthComputable = e.lengthComputable;\n      metadataLoaded = e.loaded;\n      metadataTotal = e.total;\n      progressHandler();\n    }, error => {\n      this.manager.itemError(metadataUrl);\n      if (typeof onError === 'function') onError(error);\n    });\n    return quadRenderer;\n  }\n}\n\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass HDRJPGLoader extends LoaderBase {\n  /**\n   * Loads a JPEG containing gain map metadata\n   * Renders a normal SDR image if gainmap data is not found\n   *\n   * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n   * @param onLoad Load complete callback, will receive the result\n   * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n   * @param onError Error callback\n   * @returns\n   */\n  load(url, onLoad, onProgress, onError) {\n    const quadRenderer = this.prepareQuadRenderer();\n    const loader = new FileLoader(this._internalLoadingManager);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setPath(this.path);\n    loader.setWithCredentials(this.withCredentials);\n    this.manager.itemStart(url);\n    loader.load(url, async jpeg => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof jpeg === 'string') throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n      const jpegBuffer = new Uint8Array(jpeg);\n      let sdrJPEG;\n      let gainMapJPEG;\n      let metadata;\n      try {\n        const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n        // gain map is successfully reconstructed\n        sdrJPEG = extractionResult.sdr;\n        gainMapJPEG = extractionResult.gainMap;\n        metadata = extractionResult.metadata;\n      } catch (e) {\n        // render the SDR version if this is not a gainmap\n        if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n          console.warn(\"Failure to reconstruct an HDR image from \".concat(url, \": Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg\"));\n          metadata = {\n            gainMapMin: [0, 0, 0],\n            gainMapMax: [1, 1, 1],\n            gamma: [1, 1, 1],\n            hdrCapacityMin: 0,\n            hdrCapacityMax: 1,\n            offsetHdr: [0, 0, 0],\n            offsetSdr: [0, 0, 0]\n          };\n          sdrJPEG = jpegBuffer;\n        } else {\n          throw e;\n        }\n      }\n      // solves #16\n      try {\n        await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);\n      } catch (error) {\n        this.manager.itemError(url);\n        if (typeof onError === 'function') onError(error);\n        quadRenderer.disposeOnDemandRenderer();\n        return;\n      }\n      if (typeof onLoad === 'function') onLoad(quadRenderer);\n      this.manager.itemEnd(url);\n      quadRenderer.disposeOnDemandRenderer();\n    }, onProgress, error => {\n      this.manager.itemError(url);\n      if (typeof onError === 'function') onError(error);\n    });\n    return quadRenderer;\n  }\n}\nexport { GainMapDecoderMaterial, GainMapLoader, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, MPFExtractor, QuadRenderer, decode, extractGainmapFromJPEG, extractXMP };","map":{"version":3,"names":["Q","QuadRenderer","ShaderMaterial","Vector3","NoBlending","SRGBColorSpace","LinearSRGBColorSpace","HalfFloatType","Loader","LoadingManager","Texture","UVMapping","ClampToEdgeWrapping","LinearFilter","LinearMipMapLinearFilter","RGBAFormat","UnsignedByteType","FileLoader","vertexShader","fragmentShader","GainMapDecoderMaterial","constructor","_ref","gamma","offsetHdr","offsetSdr","gainMapMin","gainMapMax","maxDisplayBoost","hdrCapacityMin","hdrCapacityMax","sdr","gainMap","name","uniforms","value","fromArray","weightFactor","Math","log2","blending","depthTest","depthWrite","_maxDisplayBoost","_hdrCapacityMin","_hdrCapacityMax","needsUpdate","uniformsNeedUpdate","toArray","g","x","y","z","calculateWeight","max","min","val","decode","params","renderer","colorSpace","console","warn","material","quadRenderer","width","image","height","type","renderTargetOptions","render","e","disposeOnDemandRenderer","GainMapNotFoundError","Error","XMPMetadataNotFoundError","getAttribute","description","defaultValue","_a","returnValue","parsedValue","attributes","getNamedItem","nodeValue","node","getElementsByTagName","values","length","Array","from","map","v","innerHTML","concat","extractXMP","input","_b","str","TextDecoder","toString","start","indexOf","parser","DOMParser","end","slice","xmpBlock","xmlDocument","parseFromString","offsetSDR","offsetHDR","isArray","parseFloat","MPFExtractor","options","debug","undefined","extractFII","extractNonFII","extract","imageArrayBuffer","Promise","resolve","reject","dataView","DataView","buffer","getUint16","byteLength","offset","loops","marker","getUint8","log","formatPt","getUint32","tiffOffset","bigEnd","firstIFDOffset","dirStart","count","entriesStart","numberOfImages","i","nextIFDOffsetLen","MPImageListValPt","images","MPType","size","dataOffset","dependantImages","isFII","push","bufferBlob","Blob","imgs","imageBlob","extractGainmapFromJPEG","jpegFile","metadata","mpfExtractor","Uint8Array","arrayBuffer","getHTMLImageFromBlob","blob","img","document","createElement","onload","onerror","src","URL","createObjectURL","LoaderBase","manager","_renderer","_internalLoadingManager","setRenderer","setRenderTargetOptions","_renderTargetOptions","prepareQuadRenderer","sdrBuffer","gainMapBuffer","gainMapBlob","sdrBlob","sdrImage","gainMapImage","needsFlip","createImageBitmap","res","all","imageOrientation","ImageData","flipY","pow","GainMapLoader","load","_ref2","onLoad","onProgress","onError","sdrUrl","gainMapUrl","metadataUrl","loadCheck","error","itemError","itemEnd","sdrLengthComputable","sdrTotal","sdrLoaded","gainMapLengthComputable","gainMapTotal","gainMapLoaded","metadataLengthComputable","metadataTotal","metadataLoaded","progressHandler","total","loaded","lengthComputable","ProgressEvent","itemStart","sdrLoader","setResponseType","setRequestHeader","requestHeader","setPath","path","setWithCredentials","withCredentials","gainMapLoader","metadataLoader","json","JSON","parse","HDRJPGLoader","url","loader","jpeg","jpegBuffer","sdrJPEG","gainMapJPEG","extractionResult","JPEGRLoader"],"sources":["/Users/timothycharouk/Documents/my-app/node_modules/@monogrid/gainmap-js/dist/decode.js"],"sourcesContent":["/**\n * @monogrid/gainmap-js v3.0.5\n * With ❤️, by MONOGRID <rnd@monogrid.com>\n */\n\nimport { Q as QuadRenderer } from './QuadRenderer-6HrRQdJM.js';\nimport { ShaderMaterial, Vector3, NoBlending, SRGBColorSpace, LinearSRGBColorSpace, HalfFloatType, Loader, LoadingManager, Texture, UVMapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, FileLoader } from 'three';\n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapDecoderMaterial extends ShaderMaterial {\n    /**\n     *\n     * @param params\n     */\n    constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {\n        super({\n            name: 'GainMapDecoderMaterial',\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                sdr: { value: sdr },\n                gainMap: { value: gainMap },\n                gamma: { value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2]) },\n                offsetHdr: { value: new Vector3().fromArray(offsetHdr) },\n                offsetSdr: { value: new Vector3().fromArray(offsetSdr) },\n                gainMapMin: { value: new Vector3().fromArray(gainMapMin) },\n                gainMapMax: { value: new Vector3().fromArray(gainMapMax) },\n                weightFactor: {\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                }\n            },\n            blending: NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._maxDisplayBoost = maxDisplayBoost;\n        this._hdrCapacityMin = hdrCapacityMin;\n        this._hdrCapacityMax = hdrCapacityMax;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get sdr() { return this.uniforms.sdr.value; }\n    set sdr(value) { this.uniforms.sdr.value = value; }\n    get gainMap() { return this.uniforms.gainMap.value; }\n    set gainMap(value) { this.uniforms.gainMap.value = value; }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */\n    get offsetHdr() { return this.uniforms.offsetHdr.value.toArray(); }\n    set offsetHdr(value) { this.uniforms.offsetHdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */\n    get offsetSdr() { return this.uniforms.offsetSdr.value.toArray(); }\n    set offsetSdr(value) { this.uniforms.offsetSdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */\n    get gainMapMin() { return this.uniforms.gainMapMin.value.toArray(); }\n    set gainMapMin(value) { this.uniforms.gainMapMin.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */\n    get gainMapMax() { return this.uniforms.gainMapMax.value.toArray(); }\n    set gainMapMax(value) { this.uniforms.gainMapMax.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */\n    get gamma() {\n        const g = this.uniforms.gamma.value;\n        return [1 / g.x, 1 / g.y, 1 / g.z];\n    }\n    set gamma(value) {\n        const g = this.uniforms.gamma.value;\n        g.x = 1.0 / value[0];\n        g.y = 1.0 / value[1];\n        g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMin() { return this._hdrCapacityMin; }\n    set hdrCapacityMin(value) {\n        this._hdrCapacityMin = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMax() { return this._hdrCapacityMax; }\n    set hdrCapacityMax(value) {\n        this._hdrCapacityMax = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */\n    get maxDisplayBoost() { return this._maxDisplayBoost; }\n    set maxDisplayBoost(value) {\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n        this.calculateWeight();\n    }\n    calculateWeight() {\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n}\n\n/**\n * Decodes a gain map using a WebGLRenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = await decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nconst decode = (params) => {\n    const { sdr, gainMap, renderer } = params;\n    if (sdr.colorSpace !== SRGBColorSpace) {\n        console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n        sdr.colorSpace = SRGBColorSpace;\n    }\n    sdr.needsUpdate = true;\n    if (gainMap.colorSpace !== LinearSRGBColorSpace) {\n        console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n        gainMap.colorSpace = LinearSRGBColorSpace;\n    }\n    gainMap.needsUpdate = true;\n    const material = new GainMapDecoderMaterial({\n        ...params,\n        sdr,\n        gainMap\n    });\n    const quadRenderer = new QuadRenderer({\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        width: sdr.image.width,\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        height: sdr.image.height,\n        type: HalfFloatType,\n        colorSpace: LinearSRGBColorSpace,\n        material,\n        renderer,\n        renderTargetOptions: params.renderTargetOptions\n    });\n    try {\n        quadRenderer.render();\n    }\n    catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n\nclass GainMapNotFoundError extends Error {\n}\n\nclass XMPMetadataNotFoundError extends Error {\n}\n\nconst getAttribute = (description, name, defaultValue) => {\n    var _a;\n    let returnValue;\n    const parsedValue = (_a = description.attributes.getNamedItem(name)) === null || _a === void 0 ? void 0 : _a.nodeValue;\n    if (!parsedValue) {\n        const node = description.getElementsByTagName(name)[0];\n        if (node) {\n            const values = node.getElementsByTagName('rdf:li');\n            if (values.length === 3) {\n                returnValue = Array.from(values).map(v => v.innerHTML);\n            }\n            else {\n                throw new Error(`Gainmap metadata contains an array of items for ${name} but its length is not 3`);\n            }\n        }\n        else {\n            if (defaultValue)\n                return defaultValue;\n            else\n                throw new Error(`Can't find ${name} in gainmap metadata`);\n        }\n    }\n    else {\n        returnValue = parsedValue;\n    }\n    return returnValue;\n};\n/**\n *\n * @param input\n * @returns\n */\nconst extractXMP = (input) => {\n    var _a, _b;\n    let str;\n    // support node test environment\n    if (typeof TextDecoder !== 'undefined')\n        str = new TextDecoder().decode(input);\n    else\n        str = input.toString();\n    let start = str.indexOf('<x:xmpmeta');\n    const parser = new DOMParser();\n    while (start !== -1) {\n        const end = str.indexOf('x:xmpmeta>', start);\n        str.slice(start, end + 10);\n        const xmpBlock = str.slice(start, end + 10);\n        try {\n            const xmlDocument = parser.parseFromString(xmpBlock, 'text/xml');\n            const description = xmlDocument.getElementsByTagName('rdf:Description')[0];\n            const gainMapMin = getAttribute(description, 'hdrgm:GainMapMin', '0');\n            const gainMapMax = getAttribute(description, 'hdrgm:GainMapMax');\n            const gamma = getAttribute(description, 'hdrgm:Gamma', '1');\n            const offsetSDR = getAttribute(description, 'hdrgm:OffsetSDR', '0.015625');\n            const offsetHDR = getAttribute(description, 'hdrgm:OffsetHDR', '0.015625');\n            let hdrCapacityMin = (_a = description.attributes.getNamedItem('hdrgm:HDRCapacityMin')) === null || _a === void 0 ? void 0 : _a.nodeValue;\n            if (!hdrCapacityMin)\n                hdrCapacityMin = '0';\n            const hdrCapacityMax = (_b = description.attributes.getNamedItem('hdrgm:HDRCapacityMax')) === null || _b === void 0 ? void 0 : _b.nodeValue;\n            if (!hdrCapacityMax)\n                throw new Error('Incomplete gainmap metadata');\n            return {\n                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n                gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n                hdrCapacityMin: parseFloat(hdrCapacityMin),\n                hdrCapacityMax: parseFloat(hdrCapacityMax)\n            };\n        }\n        catch (e) {\n        }\n        start = str.indexOf('<x:xmpmeta', end);\n    }\n};\n\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */\nclass MPFExtractor {\n    constructor(options) {\n        this.options = {\n            debug: options && options.debug !== undefined ? options.debug : false,\n            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n        };\n    }\n    extract(imageArrayBuffer) {\n        return new Promise((resolve, reject) => {\n            const debug = this.options.debug;\n            const dataView = new DataView(imageArrayBuffer.buffer);\n            // If you're executing this line on a big endian machine, it'll be reversed.\n            // bigEnd further down though, refers to the endianness of the image itself.\n            if (dataView.getUint16(0) !== 0xffd8) {\n                reject(new Error('Not a valid jpeg'));\n                return;\n            }\n            const length = dataView.byteLength;\n            let offset = 2;\n            let loops = 0;\n            let marker; // APP# marker\n            while (offset < length) {\n                if (++loops > 250) {\n                    reject(new Error(`Found no marker after ${loops} loops 😵`));\n                    return;\n                }\n                if (dataView.getUint8(offset) !== 0xff) {\n                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                    return;\n                }\n                marker = dataView.getUint8(offset + 1);\n                if (debug)\n                    console.log(`Marker: ${marker.toString(16)}`);\n                if (marker === 0xe2) {\n                    if (debug)\n                        console.log('Found APP2 marker (0xffe2)');\n                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                    // Great way to visualize image information in html is using Exiftool. E.g.:\n                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                    const formatPt = offset + 4;\n                    /*\n                     *  Structure of the MP Format Identifier\n                     *\n                     *  Offset Addr.  | Code (Hex)  | Description\n                     *  +00             ff            Marker Prefix      <-- offset\n                     *  +01             e2            APP2\n                     *  +02             #n            APP2 Field Length\n                     *  +03             #n            APP2 Field Length\n                     *  +04             4d            'M'                <-- formatPt\n                     *  +05             50            'P'\n                     *  +06             46            'F'\n                     *  +07             00            NULL\n                     *                                                   <-- tiffOffset\n                     */\n                    if (dataView.getUint32(formatPt) === 0x4d504600) {\n                        // Found MPF tag, so we start dig out sub images\n                        const tiffOffset = formatPt + 4;\n                        let bigEnd; // Endianness from TIFF header\n                        // Test for TIFF validity and endianness\n                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                        if (dataView.getUint16(tiffOffset) === 0x4949) {\n                            bigEnd = false;\n                        }\n                        else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                            bigEnd = true;\n                        }\n                        else {\n                            reject(new Error('No valid endianness marker found in TIFF header'));\n                            return;\n                        }\n                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                            reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n                            return;\n                        }\n                        // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                        if (firstIFDOffset < 0x00000008) {\n                            reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n                            return;\n                        }\n                        // Move ahead to MP Index IFD\n                        // Assume we're at the first IFD, so firstIFDOffset points to\n                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                        // we fail silently here due to this assumption)\n                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                        // Extract info from MPEntries (starting after Count)\n                        const entriesStart = dirStart + 2;\n                        let numberOfImages = 0;\n                        for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n                            // Each entry is 12 Bytes long\n                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                // stored in Last 4 bytes of its 12 Byte entry.\n                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                            }\n                        }\n                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                        const images = [];\n                        for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n                            const image = {\n                                MPType: dataView.getUint32(i, !bigEnd),\n                                size: dataView.getUint32(i + 4, !bigEnd),\n                                // This offset is specified relative to the address of the MP Endian\n                                // field in the MP Header, unless the image is a First Individual Image,\n                                // in which case the value of the offset shall be NULL (0x00000000).\n                                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                start: -1,\n                                end: -1,\n                                isFII: false\n                            };\n                            if (!image.dataOffset) {\n                                // dataOffset is 0x00000000 for First Individual Image\n                                image.start = 0;\n                                image.isFII = true;\n                            }\n                            else {\n                                image.start = tiffOffset + image.dataOffset;\n                                image.isFII = false;\n                            }\n                            image.end = image.start + image.size;\n                            images.push(image);\n                        }\n                        if (this.options.extractNonFII && images.length) {\n                            const bufferBlob = new Blob([dataView]);\n                            const imgs = [];\n                            for (const image of images) {\n                                if (image.isFII && !this.options.extractFII) {\n                                    continue; // Skip FII\n                                }\n                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                                // we don't need this\n                                // const imageUrl = URL.createObjectURL(imageBlob)\n                                // image.img = document.createElement('img')\n                                // image.img.src = imageUrl\n                                imgs.push(imageBlob);\n                            }\n                            resolve(imgs);\n                        }\n                    }\n                }\n                offset += 2 + dataView.getUint16(offset + 2);\n            }\n        });\n    }\n}\n\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */\nconst extractGainmapFromJPEG = async (jpegFile) => {\n    const metadata = extractXMP(jpegFile);\n    if (!metadata)\n        throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n    const mpfExtractor = new MPFExtractor({ extractFII: true, extractNonFII: true });\n    const images = await mpfExtractor.extract(jpegFile);\n    if (images.length !== 2)\n        throw new GainMapNotFoundError('Gain map recovery image not found');\n    return {\n        sdr: new Uint8Array(await images[0].arrayBuffer()),\n        gainMap: new Uint8Array(await images[1].arrayBuffer()),\n        metadata\n    };\n};\n\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */\nconst getHTMLImageFromBlob = (blob) => {\n    return new Promise((resolve, reject) => {\n        const img = document.createElement('img');\n        img.onload = () => { resolve(img); };\n        img.onerror = (e) => { reject(e); };\n        img.src = URL.createObjectURL(blob);\n    });\n};\n\nclass LoaderBase extends Loader {\n    /**\n     *\n     * @param renderer\n     * @param manager\n     */\n    constructor(renderer, manager) {\n        super(manager);\n        if (renderer)\n            this._renderer = renderer;\n        this._internalLoadingManager = new LoadingManager();\n    }\n    /**\n     * Specify the renderer to use when rendering the gain map\n     *\n     * @param renderer\n     * @returns\n     */\n    setRenderer(renderer) {\n        this._renderer = renderer;\n        return this;\n    }\n    /**\n     * Specify the renderTarget options to use when rendering the gain map\n     *\n     * @param options\n     * @returns\n     */\n    setRenderTargetOptions(options) {\n        this._renderTargetOptions = options;\n        return this;\n    }\n    /**\n     * @private\n     * @returns\n     */\n    prepareQuadRenderer() {\n        if (!this._renderer)\n            console.warn('WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n        // temporary values\n        const material = new GainMapDecoderMaterial({\n            gainMapMax: [1, 1, 1],\n            gainMapMin: [0, 0, 0],\n            gamma: [1, 1, 1],\n            offsetHdr: [1, 1, 1],\n            offsetSdr: [1, 1, 1],\n            hdrCapacityMax: 1,\n            hdrCapacityMin: 0,\n            maxDisplayBoost: 1,\n            gainMap: new Texture(),\n            sdr: new Texture()\n        });\n        return new QuadRenderer({\n            width: 16,\n            height: 16,\n            type: HalfFloatType,\n            colorSpace: LinearSRGBColorSpace,\n            material,\n            renderer: this._renderer,\n            renderTargetOptions: this._renderTargetOptions\n        });\n    }\n    /**\n   * @private\n   * @param quadRenderer\n   * @param metadata\n   * @param sdrBuffer\n   * @param gainMapBuffer\n   */\n    async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        // this is optional, will render a black gain-map if not present\n        const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], { type: 'image/jpeg' }) : undefined;\n        const sdrBlob = new Blob([sdrBuffer], { type: 'image/jpeg' });\n        let sdrImage;\n        let gainMapImage;\n        let needsFlip = false;\n        if (typeof createImageBitmap === 'undefined') {\n            const res = await Promise.all([\n                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                getHTMLImageFromBlob(sdrBlob)\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n            needsFlip = true;\n        }\n        else {\n            const res = await Promise.all([\n                gainMapBlob ? createImageBitmap(gainMapBlob, { imageOrientation: 'flipY' }) : Promise.resolve(undefined),\n                createImageBitmap(sdrBlob, { imageOrientation: 'flipY' })\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n        }\n        const gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);\n        gainMap.flipY = needsFlip;\n        gainMap.needsUpdate = true;\n        const sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);\n        sdr.flipY = needsFlip;\n        sdr.needsUpdate = true;\n        quadRenderer.width = sdrImage.width;\n        quadRenderer.height = sdrImage.height;\n        quadRenderer.material.gainMap = gainMap;\n        quadRenderer.material.sdr = sdr;\n        quadRenderer.material.gainMapMin = metadata.gainMapMin;\n        quadRenderer.material.gainMapMax = metadata.gainMapMax;\n        quadRenderer.material.offsetHdr = metadata.offsetHdr;\n        quadRenderer.material.offsetSdr = metadata.offsetSdr;\n        quadRenderer.material.gamma = metadata.gamma;\n        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n        quadRenderer.material.needsUpdate = true;\n        quadRenderer.render();\n    }\n}\n\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass GainMapLoader extends LoaderBase {\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        let sdr;\n        let gainMap;\n        let metadata;\n        const loadCheck = async () => {\n            if (sdr && gainMap && metadata) {\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\n                }\n                catch (error) {\n                    this.manager.itemError(sdrUrl);\n                    this.manager.itemError(gainMapUrl);\n                    this.manager.itemError(metadataUrl);\n                    if (typeof onError === 'function')\n                        onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === 'function')\n                    onLoad(quadRenderer);\n                this.manager.itemEnd(sdrUrl);\n                this.manager.itemEnd(gainMapUrl);\n                this.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n            }\n        };\n        let sdrLengthComputable = true;\n        let sdrTotal = 0;\n        let sdrLoaded = 0;\n        let gainMapLengthComputable = true;\n        let gainMapTotal = 0;\n        let gainMapLoaded = 0;\n        let metadataLengthComputable = true;\n        let metadataTotal = 0;\n        let metadataLoaded = 0;\n        const progressHandler = () => {\n            if (typeof onProgress === 'function') {\n                const total = sdrTotal + gainMapTotal + metadataTotal;\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                onProgress(new ProgressEvent('progress', { lengthComputable, loaded, total }));\n            }\n        };\n        this.manager.itemStart(sdrUrl);\n        this.manager.itemStart(gainMapUrl);\n        this.manager.itemStart(metadataUrl);\n        const sdrLoader = new FileLoader(this._internalLoadingManager);\n        sdrLoader.setResponseType('arraybuffer');\n        sdrLoader.setRequestHeader(this.requestHeader);\n        sdrLoader.setPath(this.path);\n        sdrLoader.setWithCredentials(this.withCredentials);\n        sdrLoader.load(sdrUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid sdr buffer');\n            sdr = buffer;\n            await loadCheck();\n        }, (e) => {\n            sdrLengthComputable = e.lengthComputable;\n            sdrLoaded = e.loaded;\n            sdrTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(sdrUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const gainMapLoader = new FileLoader(this._internalLoadingManager);\n        gainMapLoader.setResponseType('arraybuffer');\n        gainMapLoader.setRequestHeader(this.requestHeader);\n        gainMapLoader.setPath(this.path);\n        gainMapLoader.setWithCredentials(this.withCredentials);\n        gainMapLoader.load(gainMapUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid gainmap buffer');\n            gainMap = buffer;\n            await loadCheck();\n        }, (e) => {\n            gainMapLengthComputable = e.lengthComputable;\n            gainMapLoaded = e.loaded;\n            gainMapTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(gainMapUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const metadataLoader = new FileLoader(this._internalLoadingManager);\n        // metadataLoader.setResponseType('json')\n        metadataLoader.setRequestHeader(this.requestHeader);\n        metadataLoader.setPath(this.path);\n        metadataLoader.setWithCredentials(this.withCredentials);\n        metadataLoader.load(metadataUrl, async (json) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof json !== 'string')\n                throw new Error('Invalid metadata string');\n            // TODO: implement check on JSON file and remove this eslint disable\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metadata = JSON.parse(json);\n            await loadCheck();\n        }, (e) => {\n            metadataLengthComputable = e.lengthComputable;\n            metadataLoaded = e.loaded;\n            metadataTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(metadataUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass HDRJPGLoader extends LoaderBase {\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load(url, onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        const loader = new FileLoader(this._internalLoadingManager);\n        loader.setResponseType('arraybuffer');\n        loader.setRequestHeader(this.requestHeader);\n        loader.setPath(this.path);\n        loader.setWithCredentials(this.withCredentials);\n        this.manager.itemStart(url);\n        loader.load(url, async (jpeg) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof jpeg === 'string')\n                throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n            const jpegBuffer = new Uint8Array(jpeg);\n            let sdrJPEG;\n            let gainMapJPEG;\n            let metadata;\n            try {\n                const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n            }\n            catch (e) {\n                // render the SDR version if this is not a gainmap\n                if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                    metadata = {\n                        gainMapMin: [0, 0, 0],\n                        gainMapMax: [1, 1, 1],\n                        gamma: [1, 1, 1],\n                        hdrCapacityMin: 0,\n                        hdrCapacityMax: 1,\n                        offsetHdr: [0, 0, 0],\n                        offsetSdr: [0, 0, 0]\n                    };\n                    sdrJPEG = jpegBuffer;\n                }\n                else {\n                    throw e;\n                }\n            }\n            // solves #16\n            try {\n                await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);\n            }\n            catch (error) {\n                this.manager.itemError(url);\n                if (typeof onError === 'function')\n                    onError(error);\n                quadRenderer.disposeOnDemandRenderer();\n                return;\n            }\n            if (typeof onLoad === 'function')\n                onLoad(quadRenderer);\n            this.manager.itemEnd(url);\n            quadRenderer.disposeOnDemandRenderer();\n        }, onProgress, (error) => {\n            this.manager.itemError(url);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\nexport { GainMapDecoderMaterial, GainMapLoader, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, MPFExtractor, QuadRenderer, decode, extractGainmapFromJPEG, extractXMP };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}