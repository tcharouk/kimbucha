{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Float32BufferAttribute, InstancedBufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, Vector3 } from 'three';\nfunction computeMikkTSpaceTangents(geometry, MikkTSpace) {\n  let negateSign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!MikkTSpace || !MikkTSpace.isReady) {\n    throw new Error('BufferGeometryUtils: Initialized MikkTSpace library required.');\n  }\n  if (!geometry.hasAttribute('position') || !geometry.hasAttribute('normal') || !geometry.hasAttribute('uv')) {\n    throw new Error('BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.');\n  }\n  function getAttributeArray(attribute) {\n    if (attribute.normalized || attribute.isInterleavedBufferAttribute) {\n      const dstArray = new Float32Array(attribute.count * attribute.itemSize);\n      for (let i = 0, j = 0; i < attribute.count; i++) {\n        dstArray[j++] = attribute.getX(i);\n        dstArray[j++] = attribute.getY(i);\n        if (attribute.itemSize > 2) {\n          dstArray[j++] = attribute.getZ(i);\n        }\n      }\n      return dstArray;\n    }\n    if (attribute.array instanceof Float32Array) {\n      return attribute.array;\n    }\n    return new Float32Array(attribute.array);\n  }\n\n  // MikkTSpace algorithm requires non-indexed input.\n\n  const _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n  // Compute vertex tangents.\n\n  const tangents = MikkTSpace.generateTangents(getAttributeArray(_geometry.attributes.position), getAttributeArray(_geometry.attributes.normal), getAttributeArray(_geometry.attributes.uv));\n\n  // Texture coordinate convention of glTF differs from the apparent\n  // default of the MikkTSpace library; .w component must be flipped.\n\n  if (negateSign) {\n    for (let i = 3; i < tangents.length; i += 4) {\n      tangents[i] *= -1;\n    }\n  }\n\n  //\n\n  _geometry.setAttribute('tangent', new BufferAttribute(tangents, 4));\n  if (geometry !== _geometry) {\n    geometry.copy(_geometry);\n  }\n  return geometry;\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries(geometries) {\n  let useGroups = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  for (let i = 0; i < geometries.length; ++i) {\n    const geometry = geometries[i];\n    let attributesCount = 0;\n\n    // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geometry.index !== null)) {\n      console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n      return null;\n    }\n\n    // gather attributes, exit early if they're different\n\n    for (const name in geometry.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n      if (attributes[name] === undefined) attributes[name] = [];\n      attributes[name].push(geometry.attributes[name]);\n      attributesCount++;\n    }\n\n    // ensure geometries have the same number of attributes\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n      return null;\n    }\n\n    // gather morph attributes, exit early if they're different\n\n    if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n      console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n      return null;\n    }\n    for (const name in geometry.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n        return null;\n      }\n      if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n      morphAttributes[name].push(geometry.morphAttributes[name]);\n    }\n    if (useGroups) {\n      let count;\n      if (isIndexed) {\n        count = geometry.index.count;\n      } else if (geometry.attributes.position !== undefined) {\n        count = geometry.attributes.position.count;\n      } else {\n        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  }\n\n  // merge indices\n\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    for (let i = 0; i < geometries.length; ++i) {\n      const index = geometries[i].index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geometries[i].attributes.position.count;\n    }\n    mergedGeometry.setIndex(mergedIndex);\n  }\n\n  // merge attributes\n\n  for (const name in attributes) {\n    const mergedAttribute = mergeAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.');\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n\n  // merge morph attributes\n\n  for (const name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0) break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.');\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes(attributes) {\n  let TypedArray;\n  let itemSize;\n  let normalized;\n  let gpuType = -1;\n  let arrayLength = 0;\n  for (let i = 0; i < attributes.length; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n      return null;\n    }\n    if (itemSize === undefined) itemSize = attribute.itemSize;\n    if (itemSize !== attribute.itemSize) {\n      console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n      return null;\n    }\n    if (normalized === undefined) normalized = attribute.normalized;\n    if (normalized !== attribute.normalized) {\n      console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n      return null;\n    }\n    if (gpuType === -1) gpuType = attribute.gpuType;\n    if (gpuType !== attribute.gpuType) {\n      console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.');\n      return null;\n    }\n    arrayLength += attribute.count * itemSize;\n  }\n  const array = new TypedArray(arrayLength);\n  const result = new BufferAttribute(array, itemSize, normalized);\n  let offset = 0;\n  for (let i = 0; i < attributes.length; ++i) {\n    const attribute = attributes[i];\n    if (attribute.isInterleavedBufferAttribute) {\n      const tupleOffset = offset / itemSize;\n      for (let j = 0, l = attribute.count; j < l; j++) {\n        for (let c = 0; c < itemSize; c++) {\n          const value = attribute.getComponent(j, c);\n          result.setComponent(j + tupleOffset, c, value);\n        }\n      }\n    } else {\n      array.set(attribute.array, offset);\n    }\n    offset += attribute.count * itemSize;\n  }\n  if (gpuType !== undefined) {\n    result.gpuType = gpuType;\n  }\n  return result;\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute(attribute) {\n  if (attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute) {\n    return deinterleaveAttribute(attribute);\n  }\n  if (attribute.isInstancedBufferAttribute) {\n    return new InstancedBufferAttribute().copy(attribute);\n  }\n  return new BufferAttribute().copy(attribute);\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes(attributes) {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray;\n  let arrayLength = 0;\n  let stride = 0;\n\n  // calculate the length and type of the interleavedBuffer\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved');\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n\n  // Create the set of buffer attributes\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = ['getX', 'getY', 'getZ', 'getW'];\n  const setters = ['setX', 'setY', 'setZ', 'setW'];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n\n    // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        iba[setters[k]](c, attribute[getters[k]](c));\n      }\n    }\n  }\n  return res;\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute(attribute) {\n  const cons = attribute.data.array.constructor;\n  const count = attribute.count;\n  const itemSize = attribute.itemSize;\n  const normalized = attribute.normalized;\n  const array = new cons(count * itemSize);\n  let newAttribute;\n  if (attribute.isInstancedInterleavedBufferAttribute) {\n    newAttribute = new InstancedBufferAttribute(array, itemSize, normalized, attribute.meshPerAttribute);\n  } else {\n    newAttribute = new BufferAttribute(array, itemSize, normalized);\n  }\n  for (let i = 0; i < count; i++) {\n    newAttribute.setX(i, attribute.getX(i));\n    if (itemSize >= 2) {\n      newAttribute.setY(i, attribute.getY(i));\n    }\n    if (itemSize >= 3) {\n      newAttribute.setZ(i, attribute.getZ(i));\n    }\n    if (itemSize >= 4) {\n      newAttribute.setW(i, attribute.getW(i));\n    }\n  }\n  return newAttribute;\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry(geometry) {\n  const attributes = geometry.attributes;\n  const morphTargets = geometry.morphTargets;\n  const attrMap = new Map();\n  for (const key in attributes) {\n    const attr = attributes[key];\n    if (attr.isInterleavedBufferAttribute) {\n      if (!attrMap.has(attr)) {\n        attrMap.set(attr, deinterleaveAttribute(attr));\n      }\n      attributes[key] = attrMap.get(attr);\n    }\n  }\n  for (const key in morphTargets) {\n    const attr = morphTargets[key];\n    if (attr.isInterleavedBufferAttribute) {\n      if (!attrMap.has(attr)) {\n        attrMap.set(attr, deinterleaveAttribute(attr));\n      }\n      morphTargets[key] = attrMap.get(attr);\n    }\n  }\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @return {number}\n */\nfunction estimateBytesUsed(geometry) {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0;\n  for (const name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices(geometry) {\n  let tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n  tolerance = Math.max(tolerance, Number.EPSILON);\n\n  // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute('position');\n  const vertexCount = indices ? indices.count : positions.count;\n\n  // next value for triangle indices\n  let nextIndex = 0;\n\n  // attributes and new attribute arrays\n  const attributeNames = Object.keys(geometry.attributes);\n  const tmpAttributes = {};\n  const tmpMorphAttributes = {};\n  const newIndices = [];\n  const getters = ['getX', 'getY', 'getZ', 'getW'];\n  const setters = ['setX', 'setY', 'setZ', 'setW'];\n\n  // Initialize the arrays, allocating space conservatively. Extra\n  // space will be trimmed in the last step.\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const attr = geometry.attributes[name];\n    tmpAttributes[name] = new attr.constructor(new attr.array.constructor(attr.count * attr.itemSize), attr.itemSize, attr.normalized);\n    const morphAttributes = geometry.morphAttributes[name];\n    if (morphAttributes) {\n      if (!tmpMorphAttributes[name]) tmpMorphAttributes[name] = [];\n      morphAttributes.forEach((morphAttr, i) => {\n        const array = new morphAttr.array.constructor(morphAttr.count * morphAttr.itemSize);\n        tmpMorphAttributes[name][i] = new morphAttr.constructor(array, morphAttr.itemSize, morphAttr.normalized);\n      });\n    }\n  }\n\n  // convert the error tolerance to an amount of decimal places to truncate to\n  const halfTolerance = tolerance * 0.5;\n  const exponent = Math.log10(1 / tolerance);\n  const hashMultiplier = Math.pow(10, exponent);\n  const hashAdditive = halfTolerance * hashMultiplier;\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n\n    // Generate a hash for the vertex attributes at the current index 'i'\n    let hash = '';\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        hash += \"\".concat(~~(attribute[getters[k]](index) * hashMultiplier + hashAdditive), \",\");\n      }\n    }\n\n    // Add another reference to the vertex if it's already\n    // used by another index\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      // copy data to the new index in the temporary attributes\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttributes = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newArray = tmpAttributes[name];\n        const newMorphArrays = tmpMorphAttributes[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          const setterFunc = setters[k];\n          newArray[setterFunc](nextIndex, attribute[getterFunc](index));\n          if (morphAttributes) {\n            for (let m = 0, ml = morphAttributes.length; m < ml; m++) {\n              newMorphArrays[m][setterFunc](nextIndex, morphAttributes[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n\n  // generate result BufferGeometry\n  const result = geometry.clone();\n  for (const name in geometry.attributes) {\n    const tmpAttribute = tmpAttributes[name];\n    result.setAttribute(name, new tmpAttribute.constructor(tmpAttribute.array.slice(0, nextIndex * tmpAttribute.itemSize), tmpAttribute.itemSize, tmpAttribute.normalized));\n    if (!(name in tmpMorphAttributes)) continue;\n    for (let j = 0; j < tmpMorphAttributes[name].length; j++) {\n      const tmpMorphAttribute = tmpMorphAttributes[name][j];\n      result.morphAttributes[name][j] = new tmpMorphAttribute.constructor(tmpMorphAttribute.array.slice(0, nextIndex * tmpMorphAttribute.itemSize), tmpMorphAttribute.itemSize, tmpMorphAttribute.normalized);\n    }\n  }\n\n  // indices\n\n  result.setIndex(newIndices);\n  return result;\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n\n    // generate index if not present\n\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute('position');\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n        return geometry;\n      }\n    }\n\n    //\n\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (drawMode === TriangleFanDrawMode) {\n      // gl.TRIANGLE_FAN\n\n      for (let i = 1; i <= numberOfTriangles; i++) {\n        newIndices.push(index.getX(0));\n        newIndices.push(index.getX(i));\n        newIndices.push(index.getX(i + 1));\n      }\n    } else {\n      // gl.TRIANGLE_STRIP\n\n      for (let i = 0; i < numberOfTriangles; i++) {\n        if (i % 2 === 0) {\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i + 2));\n        } else {\n          newIndices.push(index.getX(i + 2));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i));\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n    }\n\n    // build final geometry\n\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n    return geometry;\n  }\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes(object) {\n  const _vA = new Vector3();\n  const _vB = new Vector3();\n  const _vC = new Vector3();\n  const _tempA = new Vector3();\n  const _tempB = new Vector3();\n  const _tempC = new Vector3();\n  const _morphA = new Vector3();\n  const _morphB = new Vector3();\n  const _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a);\n    _vB.fromBufferAttribute(attribute, b);\n    _vC.fromBufferAttribute(attribute, c);\n    const morphInfluences = object.morphTargetInfluences;\n    if (morphAttribute && morphInfluences) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i];\n        const morph = morphAttribute[i];\n        if (influence === 0) continue;\n        _tempA.fromBufferAttribute(morph, a);\n        _tempB.fromBufferAttribute(morph, b);\n        _tempC.fromBufferAttribute(morph, c);\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object.isSkinnedMesh) {\n      object.applyBoneTransform(a, _vA);\n      object.applyBoneTransform(b, _vB);\n      object.applyBoneTransform(c, _vC);\n    }\n    modifiedAttributeArray[a * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    // indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  } else {\n    // non-indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  }\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute\n  };\n}\nfunction mergeGroups(geometry) {\n  if (geometry.groups.length === 0) {\n    console.warn('THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.');\n    return geometry;\n  }\n  let groups = geometry.groups;\n\n  // sort groups by material index\n\n  groups = groups.sort((a, b) => {\n    if (a.materialIndex !== b.materialIndex) return a.materialIndex - b.materialIndex;\n    return a.start - b.start;\n  });\n\n  // create index for non-indexed geometries\n\n  if (geometry.getIndex() === null) {\n    const positionAttribute = geometry.getAttribute('position');\n    const indices = [];\n    for (let i = 0; i < positionAttribute.count; i += 3) {\n      indices.push(i, i + 1, i + 2);\n    }\n    geometry.setIndex(indices);\n  }\n\n  // sort index\n\n  const index = geometry.getIndex();\n  const newIndices = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    const groupStart = group.start;\n    const groupLength = groupStart + group.count;\n    for (let j = groupStart; j < groupLength; j++) {\n      newIndices.push(index.getX(j));\n    }\n  }\n  geometry.dispose(); // Required to force buffer recreation\n  geometry.setIndex(newIndices);\n\n  // update groups indices\n\n  let start = 0;\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    group.start = start;\n    start += group.count;\n  }\n\n  // merge groups\n\n  let currentGroup = groups[0];\n  geometry.groups = [currentGroup];\n  for (let i = 1; i < groups.length; i++) {\n    const group = groups[i];\n    if (currentGroup.materialIndex === group.materialIndex) {\n      currentGroup.count += group.count;\n    } else {\n      currentGroup = group;\n      geometry.groups.push(currentGroup);\n    }\n  }\n  return geometry;\n}\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */\nfunction toCreasedNormals(geometry) {\n  let creaseAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.PI / 3;\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 1e2;\n\n  // reusable vectors\n  const verts = [new Vector3(), new Vector3(), new Vector3()];\n  const tempVec1 = new Vector3();\n  const tempVec2 = new Vector3();\n  const tempNorm = new Vector3();\n  const tempNorm2 = new Vector3();\n\n  // hashes a vector\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return \"\".concat(x, \",\").concat(y, \",\").concat(z);\n  }\n\n  // BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n  // and returns the original geometry\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n\n  // find all the normals shared by commonly located vertices\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n\n    // add the normal to the map for all vertices\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n\n  // average normals from all vertices that share a common location if they are within the\n  // provided crease threshold\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    // get the face normal for this vertex\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n\n    // average all normals that meet the threshold and set the normal value\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute('normal', normAttr);\n  return resultGeometry;\n}\nexport { computeMikkTSpaceTangents, mergeGeometries, mergeAttributes, interleaveAttributes, estimateBytesUsed, mergeVertices, toTrianglesDrawMode, computeMorphedAttributes, mergeGroups, toCreasedNormals };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Float32BufferAttribute","InstancedBufferAttribute","InterleavedBuffer","InterleavedBufferAttribute","TriangleFanDrawMode","TriangleStripDrawMode","TrianglesDrawMode","Vector3","computeMikkTSpaceTangents","geometry","MikkTSpace","negateSign","arguments","length","undefined","isReady","Error","hasAttribute","getAttributeArray","attribute","normalized","isInterleavedBufferAttribute","dstArray","Float32Array","count","itemSize","i","j","getX","getY","getZ","array","_geometry","index","toNonIndexed","tangents","generateTangents","attributes","position","normal","uv","setAttribute","copy","mergeGeometries","geometries","useGroups","isIndexed","attributesUsed","Set","Object","keys","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","attributesCount","console","error","name","has","push","size","addGroup","indexOffset","mergedIndex","setIndex","mergedAttribute","mergeAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","gpuType","arrayLength","constructor","result","tupleOffset","l","c","value","getComponent","setComponent","set","deepCloneAttribute","isInstancedInterleavedBufferAttribute","deinterleaveAttribute","isInstancedBufferAttribute","interleaveAttributes","stride","interleavedBuffer","res","getters","setters","iba","k","cons","data","newAttribute","meshPerAttribute","setX","setY","setZ","setW","getW","deinterleaveGeometry","morphTargets","attrMap","Map","key","attr","get","estimateBytesUsed","mem","getAttribute","BYTES_PER_ELEMENT","indices","getIndex","mergeVertices","tolerance","Math","max","Number","EPSILON","hashToIndex","positions","vertexCount","nextIndex","attributeNames","tmpAttributes","tmpMorphAttributes","newIndices","forEach","morphAttr","halfTolerance","exponent","log10","hashMultiplier","pow","hashAdditive","hash","concat","newArray","newMorphArrays","getterFunc","setterFunc","m","ml","clone","tmpAttribute","slice","tmpMorphAttribute","toTrianglesDrawMode","drawMode","warn","numberOfTriangles","newGeometry","clearGroups","computeMorphedAttributes","object","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_calculateMorphedAttributeData","morphAttribute","a","b","modifiedAttributeArray","fromBufferAttribute","morphInfluences","morphTargetInfluences","il","influence","morph","addScaledVector","sub","add","isSkinnedMesh","applyBoneTransform","x","y","z","material","positionAttribute","morphPosition","normalAttribute","morphNormal","groups","drawRange","jl","group","start","end","modifiedPosition","modifiedNormal","Array","isArray","min","morphedPositionAttribute","morphedNormalAttribute","mergeGroups","sort","materialIndex","groupStart","groupLength","dispose","currentGroup","toCreasedNormals","creaseAngle","PI","creaseDot","cos","verts","tempVec1","tempVec2","tempNorm","tempNorm2","hashVertex","v","resultGeometry","posAttr","vertexMap","i3","subVectors","crossVectors","normalize","n","vert","normalArray","normAttr","otherNormals","lk","otherNorm","dot","setXYZ"],"sources":["/Users/timothycharouk/Documents/my-app/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.count * itemSize;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst tupleOffset = offset / itemSize;\n\t\t\tfor ( let j = 0, l = attribute.count; j < l; j ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tconst value = attribute.getComponent( j, c );\n\t\t\t\t\tresult.setComponent( j + tupleOffset, c, value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tarray.set( attribute.array, offset );\n\n\t\t}\n\n\t\toffset += attribute.count * itemSize;\n\n\t}\n\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new attr.constructor(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\tif ( morphAttributes ) {\n\n\t\t\tif ( ! tmpMorphAttributes[ name ] ) tmpMorphAttributes[ name ] = [];\n\t\t\tmorphAttributes.forEach( ( morphAttr, i ) => {\n\n\t\t\t\tconst array = new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize );\n\t\t\t\ttmpMorphAttributes[ name ][ i ] = new morphAttr.constructor( array, morphAttr.itemSize, morphAttr.normalized );\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst halfTolerance = tolerance * 0.5;\n\tconst exponent = Math.log10( 1 / tolerance );\n\tconst hashMultiplier = Math.pow( 10, exponent );\n\tconst hashAdditive = halfTolerance * hashMultiplier;\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttributes = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newArray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewArray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttributes ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttributes.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttributes[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new tmpAttribute.constructor(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new tmpMorphAttribute.constructor(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}